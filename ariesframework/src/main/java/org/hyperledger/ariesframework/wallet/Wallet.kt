package org.hyperledger.ariesframework.wallet

import askar_uniffi.AskarCrypto
import askar_uniffi.AskarKeyAlg
import askar_uniffi.AskarSession
import askar_uniffi.AskarStore
import askar_uniffi.AskarStoreManager
import askar_uniffi.LocalKeyFactory
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import org.hyperledger.ariesframework.DecryptedMessageContext
import org.hyperledger.ariesframework.EncryptedMessage
import org.hyperledger.ariesframework.JweRecipient
import org.hyperledger.ariesframework.ProtectedHeader
import org.hyperledger.ariesframework.agent.Agent
import org.hyperledger.ariesframework.agent.AgentMessage
import org.hyperledger.ariesframework.agent.MessageSerializer
import org.hyperledger.ariesframework.decodeBase64url
import org.hyperledger.ariesframework.encodeBase64url
import org.hyperledger.ariesframework.util.Base58
import org.slf4j.LoggerFactory
import java.io.File

const val PREFERENCE_NAME = "aries-framework-kotlin"

data class DidInfo(
    val did: String,
    val verkey: String,
)

class Wallet(private val agent: Agent) {
    private val walletExistKey = agent.agentConfig.label + " aries_framework_wallet_exist"
    private val secretIdKey = agent.agentConfig.label + " aries_framework_wallet_secret_id_key"
    private val logger = LoggerFactory.getLogger(Wallet::class.java)
    private val storeManager = AskarStoreManager()
    val keyFactory = LocalKeyFactory()
    private val crypto = AskarCrypto()
    var store: AskarStore? = null
    var session: AskarSession? = null

    // Link secret id to identify the prover in AnonCreds. This will not be nil after the agent initialization.
    var linkSecretId: String? = null
        private set

    // Public did generated by the ``AgentConfig.publicDidSeed``.
    var publicDid: DidInfo? = null
        private set

    private val storePath: String
        get() {
            val documentDirectory = agent.context.filesDir.absolutePath
            return File(documentDirectory, "wallet/${agent.agentConfig.walletId}/sqlite.db").absolutePath
        }
    private val storeUri: String
        get() {
            return "sqlite://$storePath"
        }

    suspend fun initialize() {
        logger.info("Initializing wallet for ${agent.agentConfig.label}")
        if (store != null) {
            logger.warn("Wallet already initialized.")
            close()
        }

        val userDefaults = agent.context.getSharedPreferences(PREFERENCE_NAME, 0)
        if (!userDefaults.getBoolean(walletExistKey, false)) {
            try {
                File(storePath).parentFile?.mkdirs()
                store = storeManager.provision(storeUri, "raw", agent.agentConfig.walletKey, null, true)
                userDefaults.edit().putBoolean(walletExistKey, true).commit()
            } catch (e: Exception) {
                throw RuntimeException("Wallet creation failed: ${e.message}")
            }
        } else {
            try {
                store = storeManager.open(storeUri, "raw", agent.agentConfig.walletKey, null)
                userDefaults.edit().putBoolean(walletExistKey, true).commit()
            } catch (e: Exception) {
                throw RuntimeException("Wallet open failed: ${e.message}")
            }
        }
        session = store!!.session(null)

        linkSecretId = userDefaults.getString(secretIdKey, null)
        if (linkSecretId == null) {
            linkSecretId = agent.anoncredsService.createLinkSecret()
            userDefaults.edit().putString(secretIdKey, linkSecretId).commit()
        }
    }

    suspend fun close() {
        logger.debug("Closing wallet")
        session?.close()
        store?.close()

        session = null
        store = null
        linkSecretId = null
    }

    suspend fun delete() {
        logger.debug("Deleting wallet")
        if (store != null) {
            close()
        }

        try {
            val removed = storeManager.remove(storeUri)
            if (!removed) {
                throw RuntimeException("remove() returned false")
            }
        } catch (e: Exception) {
            logger.debug("Wallet deletion failed: ${e.message}")
            logger.warn("Cannot delete wallet. Try to delete wallet file manually.")
            File(storePath).delete()
        }

        with(agent.context.getSharedPreferences(PREFERENCE_NAME, 0).edit()) {
            remove(walletExistKey)
            remove(secretIdKey)
            commit()
        }
    }

    suspend fun initPublicDid(seed: String) {
        publicDid = createDid(seed)
    }

    suspend fun createDid(seed: String? = null): DidInfo {
        // Use fromSecretBytes() instead of fromSeed() for compatibility with indy-sdk
        val key = if (seed == null) {
            keyFactory.generate(AskarKeyAlg.ED25519, false)
        } else {
            keyFactory.fromSecretBytes(AskarKeyAlg.ED25519, seed.toByteArray())
        }

        val publicKey = key.toPublicBytes()
        val verkey = Base58.encode(publicKey)
        val did = Base58.encode(publicKey.copyOfRange(0, 16))
        try {
            session!!.insertKey(verkey, key, null, null, null)
        } catch (e: Exception) {
            logger.error("Ignoring error. Failed to insert key: ${e.message}")
        }
        logger.debug("Created DID $did with verkey $verkey")

        return DidInfo(did, verkey)
    }

    suspend fun pack(
        message: AgentMessage,
        recipientKeys: List<String>,
        senderVerkey: String?,
    ): EncryptedMessage {
        val cek = keyFactory.generate(AskarKeyAlg.C20P, true)
        val senderKey = if (senderVerkey != null) {
            session!!.fetchKey(senderVerkey, false)
        } else {
            null
        }
        if (senderVerkey != null && senderKey == null) {
            throw RuntimeException("Unable to pack message. Sender key $senderVerkey not found in wallet.")
        }
        val senderExchangeKey = senderKey?.loadLocalKey()?.convertKey(AskarKeyAlg.X25519)

        val recipients = mutableListOf<JweRecipient>()
        for (recipientKey in recipientKeys) {
            val recipientKeyBytes = Base58.decode(recipientKey)
                ?: throw RuntimeException("Invalid recipient key: $recipientKey")
            val targetExchangeKey =
                keyFactory.fromPublicBytes(AskarKeyAlg.ED25519, recipientKeyBytes)
                    .convertKey(AskarKeyAlg.X25519)
            if (senderVerkey != null && senderExchangeKey != null) {
                val encryptedSender = crypto.boxSeal(targetExchangeKey, senderVerkey.toByteArray())
                val nonce = crypto.randomNonce()
                val encryptedCek = crypto.cryptoBox(
                    targetExchangeKey,
                    senderExchangeKey,
                    cek.toSecretBytes(),
                    nonce,
                )

                recipients.add(
                    JweRecipient(
                        encryptedCek.encodeBase64url(),
                        mapOf(
                            "kid" to recipientKey,
                            "sender" to encryptedSender.encodeBase64url(),
                            "iv" to nonce.encodeBase64url(),
                        ),
                    ),
                )
            } else {
                val encryptedCek = crypto.boxSeal(targetExchangeKey, cek.toSecretBytes())
                recipients.add(
                    JweRecipient(
                        encryptedCek.encodeBase64url(),
                        mapOf("kid" to recipientKey),
                    ),
                )
            }
        }

        val protected = ProtectedHeader(
            "xchacha20poly1305_ietf",
            "JWM/1.0",
            if (senderVerkey != null) "Authcrypt" else "Anoncrypt",
            recipients,
        )
        val protectedData = Json.encodeToString(protected).toByteArray()
        val buffer = cek.aeadEncrypt(
            MessageSerializer.encodeToString(message).toByteArray(),
            null,
            protectedData.encodeBase64url().toByteArray(),
        )

        return EncryptedMessage(
            protectedData.encodeBase64url(),
            buffer.nonce().encodeBase64url(),
            buffer.ciphertext().encodeBase64url(),
            buffer.tag().encodeBase64url(),
        )
    }

    suspend fun unpack(encryptedMessage: EncryptedMessage): DecryptedMessageContext {
        val protected = Json.decodeFromString<ProtectedHeader>(String(encryptedMessage.protected.decodeBase64url()))
        if (protected.alg != "Anoncrypt" && protected.alg != "Authcrypt") {
            throw RuntimeException("Unsupported pack algorithm: ${protected.alg}")
        }

        var senderKey: String? = null
        var recipientKey: String? = null
        var payloadKey: ByteArray? = null
        for (recipient in protected.recipients) {
            val kid = recipient.header?.get("kid")
                ?: throw RuntimeException("Blank recipient key")
            val sender = recipient.header?.get("sender")?.decodeBase64url()
            val iv = recipient.header?.get("iv")?.decodeBase64url()
            if (sender != null && iv == null) {
                throw RuntimeException("Missing IV")
            } else if (sender == null && iv != null) {
                throw RuntimeException("Unexpected IV")
            }
            val encryptedKey = recipient.encryptedKey.decodeBase64url()

            val recipientKeyEntry = session!!.fetchKey(kid, false)
            if (recipientKeyEntry != null) {
                recipientKey = kid
                val recipientExchangeKey = recipientKeyEntry.loadLocalKey().convertKey(AskarKeyAlg.X25519)
                if (sender != null) {
                    senderKey = String(crypto.boxSealOpen(recipientExchangeKey, sender))
                    val senderKeyBytes = try {
                        Base58.decode(senderKey)
                    } catch (e: Exception) {
                        throw RuntimeException("Invalid sender key: $senderKey")
                    }
                    val senderExchangeKey =
                        keyFactory.fromPublicBytes(AskarKeyAlg.ED25519, senderKeyBytes)
                            .convertKey(AskarKeyAlg.X25519)
                    payloadKey = crypto.boxOpen(recipientExchangeKey, senderExchangeKey, encryptedKey, iv!!)
                } else {
                    payloadKey = crypto.boxSealOpen(recipientExchangeKey, encryptedKey)
                }
            } else {
                logger.debug("Recipient key $kid not found in wallet")
            }
        }

        if (senderKey == null && protected.alg == "Authcrypt") {
            throw RuntimeException("Sender public key not provided for Authcrypt")
        }
        if (payloadKey == null) {
            throw RuntimeException("No corresponding recipient key found")
        }

        val cek = keyFactory.fromSecretBytes(AskarKeyAlg.C20P, payloadKey)
        val message = cek.aeadDecrypt(
            encryptedMessage.ciphertext.decodeBase64url(),
            encryptedMessage.tag.decodeBase64url(),
            encryptedMessage.iv.decodeBase64url(),
            encryptedMessage.protected.toByteArray(),
        )

        return DecryptedMessageContext(String(message), senderKey, recipientKey)
    }
}
